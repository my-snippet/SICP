;;;; query-driver-loop
;; 1. It(query-driver-loop) repeatedly reads input expressions
;; 2. The driver passes this query to the evaluator qeval together with an initial frame stream
;; 3. The result of the evaluation is a stream of frames generated by satisfying the query
;; 4. query variable is changed to the values supplied by the stream of frames
(define input-prompt  ";;; Query input:")
(define output-prompt ";;; Query results:")

(define (query-driver-loop)
  (prompt-for-input input-prompt)
  (let ((q (query-syntax-process (read))))
	(cond ((assertion-to-be-added? q)
		   (add-rule-or-assertion!
			(add-assertion-body q))
		   (newline)
		   (display
			"Assertion added to data base.")
		   (query-driver-loop))
		  (else
		   (newline)
		   (display output-prompt)
		   (display-stream
			(stream-map
			 (lambda (frame)
			   (instantiate
				q
				frame
				(lambda (v f)
				  (contract-question-mark v))))
			 (qeval q (singleton-stream '()))))
		   (query-driver-loop)))))
;; The expressions of the query language
;; 1. The implementation of the expression syntax
;; predicate : assertion-to-be-added?
;; selector : add-assertion-body 
;; 2. transformations to make the processing more efficient 
;; procedure : query-syntax-process, contract-question-mark


;;;; Instantiation
;; To instantiate an expression, we copy it, replacing any variables
;; in the expression by their values in a given frame.
;; The values are themselves instantiated, since they could contain variables
(define (instantiate
		 exp frame unbound-var-handler)
  (define (copy exp)
	(cond ((var? exp)
		   (let ((binding
				  (binding-in-frame
				   exp frame)))
			 (if binding
				 (copy
				  (binding-value binding))
				 (unbound-var-handler
				  exp frame))))
		  ((pair? exp)
		   (cons (copy (car exp))
				 (copy (cdr exp))))
		  (else exp)))
  (copy exp))
